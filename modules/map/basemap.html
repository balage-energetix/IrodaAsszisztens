<!DOCTYPE html>
<html lang="hu" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alaptérkép Gyorsbetöltő</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2196f3;
            --accent: #ff4081;
            --bg-dark: #1e1e1e;
            --text-light: #ffffff;
            --toolbar-bg: rgba(30, 30, 30, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
            font-family: 'Outfit', sans-serif;
            width: 100vw;
            height: 100vh;
        }

        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            cursor: grab;
            background: #222;
        }

        #viewport.drawing {
            cursor: crosshair;
        }

        #map-container {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        #base-map {
            display: block;
            pointer-events: none;
            /* Let events pass to canvas */
        }

        #drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            /* We'll handle events on the viewport */
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            inset: 0;
        }

        .toolbar {
            pointer-events: auto;
            background: var(--toolbar-bg);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 12px;
            display: flex;
            gap: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .top-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .search-box {
            display: flex;
            gap: 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .search-box input {
            border: none;
            padding: 12px;
            flex: 1;
            outline: none;
            font-family: inherit;
        }

        .search-box button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0 20px;
            cursor: pointer;
            transition: 0.2s;
        }

        .search-box button:hover {
            background: #1976d2;
        }

        .tools-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .icon-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: 0.2s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .icon-btn.active {
            background: var(--primary);
            box-shadow: 0 0 15px var(--primary);
        }

        .icon-btn.danger {
            background: rgba(244, 67, 54, 0.2);
            color: #ff5252;
        }

        .icon-btn.danger:hover {
            background: rgba(244, 67, 54, 0.4);
        }

        .zoom-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            flex-direction: column;
        }

        .back-btn {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-decoration: none;
            font-weight: 800;
            padding: 12px 24px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            transition: 0.2s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Print styles */
        @media print {

            .ui-layer,
            .back-btn {
                display: none !important;
            }

            body,
            html,
            #viewport {
                background: white;
                height: 100%;
                width: 100%;
                overflow: visible;
            }

            @page {
                size: landscape;
                margin: 0;
            }

            /* We will handle the print content via JS injection to ensure WYSIWYG */
        }

        /* Glowing highlight for search results */
        .highlight-box {
            position: absolute;
            border: 4px solid #ffeb3b;
            box-shadow: 0 0 20px #ffeb3b, inset 0 0 20px #ffeb3b;
            z-index: 50;
            animation: pulse-glow 1.5s infinite;
            pointer-events: none;
            display: none;
        }

        @keyframes pulse-glow {
            0% {
                opacity: 1;
                box-shadow: 0 0 20px #ffeb3b;
            }

            50% {
                opacity: 0.6;
                box-shadow: 0 0 40px #ffeb3b;
            }

            100% {
                opacity: 1;
                box-shadow: 0 0 20px #ffeb3b;
            }
        }
    </style>
</head>

<body>

    <div id="viewport">
        <div id="map-container">
            <img id="base-map" src="../../nyilvantartas/ALAPTÉRKÉP-1.png" alt="Alaptérkép">
            <canvas id="drawing-layer"></canvas>
            <div id="highlight" class="highlight-box"></div>
        </div>
    </div>

    <div class="ui-layer">
        <div class="top-bar">
            <!-- Left Tools -->
            <div class="toolbar tools-panel">
                <button class="icon-btn active" id="tool-pan" title="Mozgatás (H)"><i
                        class="fas fa-hand-paper"></i></button>
                <div style="width:100%; height:1px; background:rgba(255,255,255,0.2); margin: 2px 0;"></div>
                <button class="icon-btn" id="tool-brush" title="Piros Ecset (B)"><i class="fas fa-paint-brush"
                        style="color:#ff5252;"></i></button>
                <button class="icon-btn" id="tool-circle" title="Kör Rajzolás (C)"><i
                        class="far fa-circle"></i></button>
                <button class="icon-btn" id="tool-square" title="Négyzet Rajzolás (S)"><i
                        class="far fa-square"></i></button>
                <div style="width:100%; height:1px; background:rgba(255,255,255,0.2); margin: 2px 0;"></div>
                <button class="icon-btn danger" id="tool-clear" title="Rajzok Törlése"><i
                        class="fas fa-trash"></i></button>
            </div>

            <!-- Search -->
            <div class="search-box pointer-events-auto">
                <input type="text" id="searchInput" placeholder="Utca, HRSZ keresés...">
                <button id="searchBtn"><i class="fas fa-search"></i></button>
            </div>

            <!-- Right Actions -->
            <div class="toolbar">
                <button class="icon-btn" id="btn-print" title="Nyomtatás"><i class="fas fa-print"></i></button>
            </div>
        </div>

        <div class="toolbar zoom-controls">
            <button class="icon-btn" id="btn-zoom-in"><i class="fas fa-plus"></i></button>
            <button class="icon-btn" id="btn-zoom-out"><i class="fas fa-minus"></i></button>
            <button class="icon-btn" id="btn-reset"><i class="fas fa-compress-arrows-alt"></i></button>
        </div>

        <a href="../../index.html" class="back-btn">
            <i class="fas fa-arrow-left"></i> Vissza a vezérlőpultra
        </a>
    </div>

    <script>
        const state = {
            scale: 0.1, // Start zoomed out to see everything
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0,
            mode: 'pan', // pan, brush, circle, square
            isDrawing: false,
            drawStartX: 0,
            drawStartY: 0
        };

        const viewport = document.getElementById('viewport');
        const mapContainer = document.getElementById('map-container');
        const img = document.getElementById('base-map');
        const canvas = document.getElementById('drawing-layer');
        const ctx = canvas.getContext('2d');
        const highlight = document.getElementById('highlight');

        // Transform controls
        function setTransform() {
            mapContainer.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`;
        }

        // Initialize
        img.onload = () => {
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            // Center init
            const viewportRect = viewport.getBoundingClientRect();
            state.scale = Math.min(viewportRect.width / img.naturalWidth, viewportRect.height / img.naturalHeight);
            state.pointX = (viewportRect.width - img.naturalWidth * state.scale) / 2;
            state.pointY = (viewportRect.height - img.naturalHeight * state.scale) / 2;
            setTransform();
        };

        // Mouse Events for Pan & Draw
        viewport.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only left click

            if (state.mode === 'pan') {
                state.panning = true;
                state.startX = e.clientX - state.pointX;
                state.startY = e.clientY - state.pointY;
                viewport.style.cursor = 'grabbing';
            } else {
                // Drawing modes
                state.isDrawing = true;
                const rect = mapContainer.getBoundingClientRect();
                // Calculate coord relative to canvas (unscaled)
                state.drawStartX = (e.clientX - rect.left) / state.scale;
                state.drawStartY = (e.clientY - rect.top) / state.scale;

                ctx.beginPath();
                ctx.strokeStyle = '#ff0000'; // Default red
                ctx.lineWidth = 5 / state.scale; // Scale stroke with zoom to keep visibility or keep const? User said red brush.
                // Keeping constant pixel width on screen relative to image means thicker on image when zoomed out. 
                // Let's set a reasonable fixed width on canvas
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.moveTo(state.drawStartX, state.drawStartY);
            }
        });

        viewport.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (state.mode === 'pan' && state.panning) {
                state.pointX = e.clientX - state.startX;
                state.pointY = e.clientY - state.startY;
                setTransform();
            } else if (state.mode !== 'pan' && state.isDrawing) {
                const rect = mapContainer.getBoundingClientRect();
                const currX = (e.clientX - rect.left) / state.scale;
                const currY = (e.clientY - rect.top) / state.scale;

                if (state.mode === 'brush') {
                    ctx.lineTo(currX, currY);
                    ctx.stroke();
                }
                // For shapes we'll handle in mouseup/using temp preview if we wanted, but for MVP simple direct draw or single shape?
                // User said "ecsettel... kört... négyzetet".
                // Usually shape tools need a preview. I will implement simple drag-to-make shape logic with a "preview" clear.
                // Since I'm drawing on the main canvas directly, I need to save state or use a temp canvas. 
                // For simplicity here: Brush is direct. Shapes will be drawn on mouseup. 
                // To show preview, I would need a temp canvas. Let's stick to simple "Brush works immediately, Shapes appear on release" or better:
                // Let's just do Brush for now as continuous, and Shapes as simple drag.
                // Limitation: No preview for shapes in this simple implementation without a secondary canvas. 
                // I'll add a quick "preview" by clearing and redrawing the shape if it's a shape tool? No, that clears previous drawings.
                // I will skip preview for shapes to keep it robust, just draw on mouseup.
            }
        });

        viewport.addEventListener('mouseup', (e) => {
            if (state.mode === 'pan') {
                state.panning = false;
                viewport.style.cursor = 'grab';
            } else if (state.isDrawing) {
                state.isDrawing = false;
                const rect = mapContainer.getBoundingClientRect();
                const currX = (e.clientX - rect.left) / state.scale;
                const currY = (e.clientY - rect.top) / state.scale;

                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 20;

                if (state.mode === 'circle') {
                    const radius = Math.sqrt(Math.pow(currX - state.drawStartX, 2) + Math.pow(currY - state.drawStartY, 2));
                    ctx.beginPath();
                    ctx.arc(state.drawStartX, state.drawStartY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (state.mode === 'square') {
                    const w = currX - state.drawStartX;
                    const h = currY - state.drawStartY;
                    ctx.strokeRect(state.drawStartX, state.drawStartY, w, h);
                }
            }
        });

        viewport.addEventListener('mouseleave', () => {
            state.panning = false;
            state.isDrawing = false;
        });

        // Zoom
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const xs = (e.clientX - state.pointX) / state.scale;
            const ys = (e.clientY - state.pointY) / state.scale;
            const delta = -Math.sign(e.deltaY);

            // Zoom factor
            const factor = 1.1;
            if (delta > 0) state.scale *= factor;
            else state.scale /= factor;

            state.pointX = e.clientX - xs * state.scale;
            state.pointY = e.clientY - ys * state.scale;
            setTransform();
        });

        // Tools
        function setMode(mode) {
            state.mode = mode;
            document.querySelectorAll('.tools-panel .icon-btn').forEach(btn => btn.classList.remove('active'));
            // simple mapping
            const map = { 'pan': 'tool-pan', 'brush': 'tool-brush', 'circle': 'tool-circle', 'square': 'tool-square' };
            const id = map[mode];
            if (id) document.getElementById(id).classList.add('active');

            viewport.className = mode === 'pan' ? '' : 'drawing';
            viewport.style.cursor = mode === 'pan' ? 'grab' : 'crosshair';
        }

        document.getElementById('tool-pan').onclick = () => setMode('pan');
        document.getElementById('tool-brush').onclick = () => setMode('brush');
        document.getElementById('tool-circle').onclick = () => setMode('circle');
        document.getElementById('tool-square').onclick = () => setMode('square');

        document.getElementById('tool-clear').onclick = () => {
            if (confirm('Biztosan törölni szeretné a rajzokat?')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        };

        // Zoom btns
        document.getElementById('btn-zoom-in').onclick = () => {
            state.scale *= 1.2;
            setTransform();
        };
        document.getElementById('btn-zoom-out').onclick = () => {
            state.scale /= 1.2;
            setTransform();
        };
        document.getElementById('btn-reset').onclick = () => {
            // Reset to fit
            const viewportRect = viewport.getBoundingClientRect();
            state.scale = Math.min(viewportRect.width / img.naturalWidth, viewportRect.height / img.naturalHeight);
            state.pointX = (viewportRect.width - img.naturalWidth * state.scale) / 2;
            state.pointY = (viewportRect.height - img.naturalHeight * state.scale) / 2;
            setTransform();
        };

        // Search
        document.getElementById('searchBtn').onclick = () => {
            const val = document.getElementById('searchInput').value;
            // Fake logic as verified with user
            if (val.toLowerCase().includes('demo')) {
                // Demo highlight center
                highlight.style.display = 'block';
                highlight.style.left = (img.naturalWidth / 2 - 100) + 'px';
                highlight.style.top = (img.naturalHeight / 2 - 50) + 'px';
                highlight.style.width = '200px';
                highlight.style.height = '100px';

                // Center view
                state.scale = 0.5;
                state.pointX = viewport.offsetWidth / 2 - (img.naturalWidth / 2) * state.scale;
                state.pointY = viewport.offsetHeight / 2 - (img.naturalHeight / 2) * state.scale;
                setTransform();
            } else {
                alert('A keresett cím vagy HRSZ nem található az adatbázisban. (Adatbázis hiányzik)');
                highlight.style.display = 'none';
            }
        };

        // Print - Current View
        document.getElementById('btn-print').onclick = () => {
            // 1. Capture current view to a new canvas that fits A4
            // User wants "aktuális ablaknézet".
            // We'll hide UI, trigger print.
            // But browsers might verify page size.
            // Let's rely on CSS media print first, but forcefully setting the body size to the view size might help.

            // To ensure it prints EXACTLY what is seen (cropped):
            // We can take the screen content and put it into a new window.
            const printContent = document.createElement('div');
            printContent.style.width = '100%';
            printContent.style.height = '100%';
            printContent.style.overflow = 'hidden';
            printContent.style.position = 'relative';

            // Clone the map container
            const clonedMap = mapContainer.cloneNode(true);
            // We need to freeze its transform
            clonedMap.style.transform = mapContainer.style.transform;
            clonedMap.style.transformOrigin = '0 0';

            // We need to set the print body to overflow hidden and same dims?
            window.print();
        };

    </script>
</body>

</html>